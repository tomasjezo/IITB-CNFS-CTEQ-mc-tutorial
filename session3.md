# Session 3

`Pythia8` offers only a restricted selection of hard processes and at a limited perturbative accuracy. Today we will learn how replace this component using `MG5_aMC@NLO` and `POWHEG` with the use of LHE interface. `MG5_aMC@NLO` is in principle capable of calculating any scattering amplitude at next-to-leading order (NLO) QCD accuracy relying on a high level of automation. `POWHEG` can reach up to next-to-next-to-leading (NNLO) for a selection of processes.

## Generating events with `MG5_aMC@NLO`+`Pythia`

`Pythia8` provides hard-scattering amplitudes for a limited set of processes, and only at leading-order (LO) accuracy. However, you can replace its hard-scattering component by supplying `Pythia8` with events generated by another program. `Pythia8` then supplements parton showers, multiple parton interactions (MPIs), and other effects.

Several tools can generate events ready for _showering_, including `Herwig`, `MG5_aMC@NLO`, `POWHEG BOX`, `Sherpa`, `WHIZARD`, and others. In this part of the tutorial, we will focus on `MG5_aMC@NLO`, a versatile program that generates events for any Standard Model process and beyond, also including radiative corrections.

We will go through an example of generating $l^+l^-$ events using `MG5_aMC@NLO` and then _showering_ them with `Pythia8`. While the typical use case involves replacing the hard-scattering component to improve it by include radiative corrections, off-shell effects, or subleading contributions, our goal here is merely to illustrate the process.

---
### Example 6: Generating the $pp \to l^+ l^-$ process with `MG5_aMC@NLO`
The typical workflow in `MG5_aMC@NLO` involves generating a process directory that contains `fortran` sources implementing scattering amplitudes. These sources can then be used to calculate differential cross sections and generate unweighted events.

You can perform both steps using the `mg5_aMC` `Python` program. To start, launch it with:
```bash
# This is shell

# Launch mg5_aMC
dexec mg5_aMC
```
This call opens an interactive terminal where you can enter commands. To generate the process directory, type the following:
```
# This is mg5_aMC shell

# Generate the amplutides
generate p p > l+ l- 

# Save them to hdd
output l+l-
```
These commands will create the process and save it in the `l+l-` directory. Inside this directory, you will find `index.html`. Opening this file with your preferred browser will provide information about the process, including contributing channels and Feynman diagrams (see the "Process Information" link):
![A screenshot of the index.html webside generated by MG5_aMC@NLO](pics/mg5Screenshot1.png)

#### Note on $ep$ collisions in `MG5_aMC@NLO`
`MG5_aMC@NLO` is fully automated and supports $ep$ collisions. I am not sure to what extent it has been validated, but we are free to have a play:
```
# This is mg5_aMC shell

# Generate DIS amplutides
generate e- p > e- j

# Save them to hdd
output DIS
```

---
### Example 7: Generating the $pp \to l^+ l^-$ event sample with `MG5_aMC@NLO`
The next step is to generate events. Launch the interactive `mg5_aMC` terminal again and type:
```
# This is mg5_aMC shell

# Launch the calculation
launch l+l- 
```
Here, `l+l-` is the name of the process directory created in Example 6.

The program will ask if you want to postprocess the events in any way (e.g., shower them, run detector simulation, decay resonances). At this point, refuse all these options by simply pressing Enter, as we will manually shower the events with `Pythia8` afterwards.

Next, the program will ask whether you want to edit:
- `param_card.dat`: Controls physics inputs like particle masses and widths, or couplings.
- `run_card.dat`: Controls center-of-mass energy, PDFs, number of events, generation cuts, and more.

Leave everything as is. The program will then proceed to calculate the differential cross sections and generate 10k events.

The "Results and Event Database" link (see the website generated in the previous example) will now contain an entry with information on this run:
![A screenshot of the index.html webside generated by MG5_aMC@NLO](pics/mg5Screenshot2.png)

The events are stored in the `LHE` format (compressed with `zlib` on-the-fly, hence the `.lhe.gz` suffix). They can be downloaded from the website or found in `./l+l-/Events/run_01/unweighted_events.lhe.gz`. _More information about this file format can be found in the Appendix._

Note: `zlib` compressed files don't necessarily need unpacking. If you inspect them with command line tools like `cat`, `less`, `grep`, etc., and your system complains that the file is binary, you can often use "z-versions" of these commands instead (e.g., `zcat`, `zless`, `zgrep`) that can read the file without unpacking it. If need be, my preferred method to unpack the file is (which preserves the original file unlike `gunzip`):
```bash
# This is shell

# Print the events to stdout and pipe them to a file
dexec zcat l+l-/Events/run_01/unweighted_events.lhe.gz > unweighted_events.lhe
```
---

There is a lot more one can do with `MG5_aMC@NLO`, to learn more please follow the tutorial available in the `mg5_aMC` program available via
```
# This is mg5_aMC shell

# Launch the tutorial
tutorial
```

--- 
### Example 8: Showering `MG5_aMC@NLO` events with `Pythia8`

The following example program instructs `Pythia8` to load events from an `LHE` file and then to _shower_ them.
```c++
// This is C++

#include "Pythia8/Pythia.h"
#include "Pythia8Plugins/HepMC3.h"
using namespace Pythia8;

int main() {

  // Interface for conversion from Pythia8::Event to HepMC event.
  // Specify file where HepMC events will be stored.
  Pythia8ToHepMC toHepMC("DY-MG5.hepmc");

  // LHE event loader.
  Pythia pythia;
  pythia.readString("Beams:frameType = 4"); // Switch on loading of LHE files
  pythia.readString("Beams:LHEF = l+l-/Events/run_01/unweighted_events.lhe.gz"); // set the LHE path and filename
  pythia.readString("TimeShower:ptMaxMatch = 1"); // use SCALUP for FSR
  pythia.readString("SpaceShower:ptMaxMatch = 1"); // use SCALUP for ISR

  // If Pythia fails to initialize, exit with error.
  if (!pythia.init()) return 1;

  // Begin event loop. Shower event. Skip if error.
  while (!pythia.info.atEndOfFile()) {
    if (!pythia.next()) continue;

    // Construct new empty HepMC event, fill it and write it out.
    toHepMC.writeNextEvent( pythia );

  // End of event loop. Statistics.
  }
  pythia.stat();

  // Done.
  return 0;
}
```
The event loop now goes on until all events in the `unweighted_events.lhe.gz` file have been read (see `pythia.info.atEndOfFile()`). The parton shower typically starts at the scale of the hard process. The choice of this scale is not unique, and correspondingly `Pythia8` offers several prescriptions through the `ptMaxMatch` setting. The value `ptMaxMatch = 1` instructs `Pythia8` to read the shower starting scale from the `LHE` file. There its value, in the `LHE` lingo known as `SCALUP`, has already been calculated by the hard event generator.

Note that `Pythia8` can load `zlib` compressed `LHE` files. 

---
### Example 9: Comparing `Pythia8` and `MG5_aMC@NLO+Pythia8` predictions

Once we analysed the event samples with `Rivet` we can compare the two predicitions to each other and to data.
```bash
# This is bash 

# Plot two yoda files
dexec rivet-mkhtml-tex DY-MG5.yoda:"Title=MG5+Pythia8" DY.yoda:"Title=Pythia8" -c plot.conf
```
Here `DY-MG5.yoda` and `DY.yoda` contain the results obtained by analysing `MG5_aMC@NLO+Pythia8` with the `rivet` program (see Example 4).

![A screenshot of the index.html website generated by Rivet opened in Safari](pics/rivetScreenshot2.png)

We note that the `MG5_aMC@NLO` prediction is drawn with a multitude of lines. This occurs because `MG5_aMC@NLO` includes scale and PDF variations in the `LHE` events -- each event contains seven weights for the usual 7pt $\mu_f$, $\mu_r$ variation, as well as one weight for each PDF error member (and more). Without specific instructions on how to plot these weights, `Rivet` simply renders all the lines.

Like this, we disable all but the first weight:
```bash
# This is bash

# Plot two yoda files, select single weight
dexec rivet-mkhtml-tex --errs DY-MG5.yoda:"Title=MG5+Pythia8:Variations=none"  DY.yoda:"Title=Pythia8" -c plot.conf

```

And like this, we instruct `Rivet` to render an envelope of a selection of weights into a scale variation band: 
```bash
# This is bash

# Plot two yoda files, with a central curve and a scale variation band
dexec rivet-mkhtml-tex --errs DY-MG5.yoda:"Title=MG5+Pythia8:Variations=none:BandComponentEnv=1,6,11,16,25,30,35,40"  DY.yoda:"Title=Pythia8" -c plot.conf
```

Which weights to select (`1,6,...`) can be figured out by looking at the `.lhe` file:
```
...
<initrwgt>
<weightgroup name="Central scale variation" combine="envelope">
<weight id="1" MUR="0.5"  MUF="0.5"  PDF="247000" > MUR=0.5 MUF=0.5  </weight>
<weight id="2" MUR="0.5"  MUF="0.5"  DYN_SCALE="1"  PDF="247000" > MUR=0.5 MUF=0.5 dyn_scale_choice=sum pt  </weight>
<weight id="3" MUR="0.5"  MUF="0.5"  DYN_SCALE="2"  PDF="247000" > MUR=0.5 MUF=0.5 dyn_scale_choice=HT  </weight>
<weight id="4" MUR="0.5"  MUF="0.5"  DYN_SCALE="3"  PDF="247000" > MUR=0.5 MUF=0.5 dyn_scale_choice=HT/2  </weight>
<weight id="5" MUR="0.5"  MUF="0.5"  DYN_SCALE="4"  PDF="247000" > MUR=0.5 MUF=0.5 dyn_scale_choice=sqrts  </weight>
<weight id="6" MUR="0.5"  MUF="1.0"  PDF="247000" > MUR=0.5  </weight>
<weight id="7" MUR="0.5"  MUF="1.0"  DYN_SCALE="1"  PDF="247000" > MUR=0.5 dyn_scale_choice=sum pt  </weight>
<weight id="8" MUR="0.5"  MUF="1.0"  DYN_SCALE="2"  PDF="247000" > MUR=0.5 dyn_scale_choice=HT  </weight>
<weight id="9" MUR="0.5"  MUF="1.0"  DYN_SCALE="3"  PDF="247000" > MUR=0.5 dyn_scale_choice=HT/2  </weight>
<weight id="10" MUR="0.5"  MUF="1.0"  DYN_SCALE="4"  PDF="247000" > MUR=0.5 dyn_scale_choice=sqrts  </weight>
...
```

This is what the plot looks like with a scale variation band:

<img alt="A screenshot of a single Rivet plot with scale variation band" src="pics/rivetScreenshot3.png" width="400">

## Appendix

Here we provide more information on topics we may have assumed that you already knew including a couple of useful references. 

### `MG5_aMC@NLO` (excerpt from the [MG5_aMC@NLO website](https://launchpad.net/mg5amcnlo))

`MadGraph5_aMC@NLO` is a framework that aims at providing all the elements necessary for SM and BSM phenomenology, such as the computations of cross sections, the generation of hard events and their matching with event generators, and the use of a variety of tools relevant to event manipulation and analysis. Processes can be simulated to LO accuracy for any user-defined Lagrangian, an the NLO accuracy in the case of models that support this kind of calculations -- prominent among these are QCD and EW corrections to SM processes. Matrix elements at the tree- and one-loop-level can also be obtained.

`MadGraph5_aMC@NLO` is the new version of both MadGraph5 and aMC@NLO that unifies the LO and NLO lines of development of automated tools within the MadGraph family. It therefore supersedes all the MadGraph5 1.5.x versions and all the beta versions of aMC@NLO. As such, the code allows one to simulate processes in virtually all configurations of interest, in particular for hadronic and e+e- colliders; starting from version 3.2.0, the latter include Initial State Radiation and beamstrahlung effects.


### `LHE` 

The `LHE` (Les Houches Event) file format is a standardized format used in high-energy physics to store information about the events generated by MC event generators. It was developed as part of the Les Houches Accords, which aim to improve the interoperability between different tools and software used in particle physics.

The `.lhe` files look something like this 
```
<LesHouchesEvents version="xy">
<header>
  <!-- Optional information like the process, PDF, scale settings, etc. -->
  <init>
    2212 2212 6.500000e+03 6.500000e+03 0 0 247000 247000 -4 1
    1.688680e+03 3.705036e+00 1.688680e+03 1
  </init>
</header>
<event>
       5      1 +1.6886800e+03 9.22950200e+01 7.54677100e-03 1.29738700e-01
       -2 -1    0    0    0  501 -0.0000000000e+00 +0.0000000000e+00 +5.3771879862e+00 5.3771879862e+00 0.0000000000e+00 0.0000e+00 -1.0000e+00
        2 -1    0    0  501    0 +0.0000000000e+00 -0.0000000000e+00 -3.9604206752e+02 3.9604206752e+02 0.0000000000e+00 0.0000e+00 1.0000e+00
       23  2    1    2    0    0 +0.0000000000e+00 +0.0000000000e+00 -3.9066487954e+02 4.0141925551e+02 9.2295019314e+01 0.0000e+00 0.0000e+00
      -11  1    3    3    0    0 -4.0335354915e+01 -2.2291993046e+01 -2.0573340903e+02 2.1083194587e+02 0.0000000000e+00 0.0000e+00 -1.0000e+00
       11  1    3    3    0    0 +4.0335354915e+01 +2.2291993046e+01 -1.8493147051e+02 1.9058730964e+02 0.0000000000e+00 0.0000e+00 1.0000e+00
</event>
</LesHouchesEvents>
```
The `<init>` block contains information about the beams (incoming particles), their energies, ...
The numbers 2212 2212 represent the PDG IDs of the incoming particles, which are protons in this case.
6500 6500 are the beam energies in GeV.
The remaining numbers can correspond to PDF IDs, factorization scales, and other relevant settings.

Each `<event>` block contains the details of one simulated event.
The first line after `<event>` summarizes the event:
- 5: The number of particles in the event.
- +1.6886800e+03: An event weight.
- 9.22950200e+01: The hard scale in the event.
- etc.

Each subsequent line describes a particle in the event. These entries include:
- PDG ID: The particle's PDG code (e.g., -1 for a down quark, 1 for an up quark).
- Status Code: Indicates the particle's status in the event (e.g., initial state, final state, intermediate).
- Parent 1 and Parent 2: Indices of the parent particles that produced this particle.
- Daughters: Indices of the particles produced by this particle (if any).
- Momentum (px, py, pz, E, m): The particle's 4-momentum (momentum components in GeV, energy in GeV, and mass in GeV).
- Spin Information: (optional) Spin/helicity information.
