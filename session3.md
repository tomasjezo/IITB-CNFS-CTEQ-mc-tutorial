# Session 3

`Pythia8` offers only a restricted selection of hard processes and at a limited perturbative accuracy. Today we will learn how replace this component using `MG5_aMC@NLO` and `POWHEG` with the use of LHE interface. `MG5_aMC@NLO` is in principle capable of calculating any scattering amplitude at next-to-leading order (NLO) QCD accuracy relying on a high level of automation. `POWHEG` can reach up to next-to-next-to-leading (NNLO) for a selection of processes.

## Generating events with `MG5_aMC@NLO`+`Pythia`

`Pythia8` provides hard-scattering amplitudes for a limited set of processes, and only at leading-order (LO) accuracy. However, you can replace its hard-scattering component by supplying `Pythia8` with events generated by another program. `Pythia8` then supplements parton showers, multiple parton interactions (MPIs), and other effects.

Several tools can generate events ready for _showering_, including `Herwig`, `MG5_aMC@NLO`, `POWHEG BOX`, `Sherpa`, `WHIZARD`, and others. In this part of the tutorial, we will focus on `MG5_aMC@NLO`, a versatile program that generates events for any Standard Model process and beyond, also including radiative corrections.

We will go through an example of generating $l^+l^-$ events using `MG5_aMC@NLO` and then _showering_ them with `Pythia8`. While the typical use case involves replacing the hard-scattering component to improve it by include radiative corrections, off-shell effects, or subleading contributions, our goal here is merely to illustrate the process.

---
### Example 6: Generating the $pp \to l^+ l^-$ process with `MG5_aMC@NLO`
The typical workflow in `MG5_aMC@NLO` involves generating a process directory that contains `fortran` sources implementing scattering amplitudes. These sources can then be used to calculate differential cross sections and generate unweighted events.

You can perform both steps using the `mg5_aMC` `Python` program. To start, launch it with:
```bash
# This is shell

# Launch mg5_aMC
dexec mg5_aMC
```
This call opens an interactive terminal where you can enter commands. To generate the process directory, type the following:
```
# This is mg5_aMC shell

# Generate the amplutides
generate p p > l+ l- 

# Save them to hdd
output l+l-
```
These commands will create the process and save it in the `l+l-` directory. Inside this directory, you will find `index.html`. Opening this file with your preferred browser will provide information about the process, including contributing channels and Feynman diagrams (see the "Process Information" link):
![A screenshot of the index.html webside generated by MG5_aMC@NLO](pics/mg5Screenshot1.png)

#### Note on $ep$ collisions in `MG5_aMC@NLO`
`MG5_aMC@NLO` is fully automated and supports $ep$ collisions. I am not sure to what extent it has been validated, but we are free to have a play:
```
# This is mg5_aMC shell

# Generate DIS amplutides
generate e- p > e- j

# Save them to hdd
output DIS
```

---
### Example 7: Generating the $pp \to l^+ l^-$ event sample with `MG5_aMC@NLO`
The next step is to generate events. Launch the interactive `mg5_aMC` terminal again and type:
```
# This is mg5_aMC shell

# Launch the calculation
launch l+l- 
```
Here, `l+l-` is the name of the process directory created in Example 6.

The program will ask if you want to postprocess the events in any way (e.g., shower them, run detector simulation, decay resonances). At this point, refuse all these options by simply pressing Enter, as we will manually shower the events with `Pythia8` afterwards.

Next, the program will ask whether you want to edit:
- `param_card.dat`: Controls physics inputs like particle masses and widths, or couplings.
- `run_card.dat`: Controls center-of-mass energy, PDFs, number of events, generation cuts, and more.

Leave everything as is. The program will then proceed to calculate the differential cross sections and generate 10k events.

The "Results and Event Database" link (see the website generated in the previous example) will now contain an entry with information on this run:
![A screenshot of the index.html webside generated by MG5_aMC@NLO](pics/mg5Screenshot2.png)

The events are stored in the `LHE` format (compressed with `zlib` on-the-fly, hence the `.lhe.gz` suffix). They can be downloaded from the website or found in `./l+l-/Events/run_01/unweighted_events.lhe.gz`. _More information about this file format can be found in the Appendix._

Note: `zlib` compressed files don't necessarily need unpacking. If you inspect them with command line tools like `cat`, `less`, `grep`, etc., and your system complains that the file is binary, you can often use "z-versions" of these commands instead (e.g., `zcat`, `zless`, `zgrep`) that can read the file without unpacking it. If need be, my preferred method to unpack the file is (which preserves the original file unlike `gunzip`):
```bash
# This is shell

# Print the events to stdout and pipe them to a file
dexec zcat l+l-/Events/run_01/unweighted_events.lhe.gz > unweighted_events.lhe
```
---

There is a lot more one can do with `MG5_aMC@NLO`, to learn more please follow the tutorial available in the `mg5_aMC` program available via
```
# This is mg5_aMC shell

# Launch the tutorial
tutorial
```

--- 
### Example 8: Showering `MG5_aMC@NLO` events with `Pythia8`

The following example program instructs `Pythia8` to load events from an `LHE` file and then to _shower_ them.
```c++
// This is C++

#include "Pythia8/Pythia.h"
#include "Pythia8Plugins/HepMC3.h"
using namespace Pythia8;

int main() {

  // Interface for conversion from Pythia8::Event to HepMC event.
  // Specify file where HepMC events will be stored.
  Pythia8ToHepMC toHepMC("DY-MG5.hepmc");

  // LHE event loader.
  Pythia pythia;
  pythia.readString("Beams:frameType = 4"); // Switch on loading of LHE files
  pythia.readString("Beams:LHEF = l+l-/Events/run_01/unweighted_events.lhe.gz"); // set the LHE path and filename
  pythia.readString("TimeShower:ptMaxMatch = 1"); // use SCALUP for FSR
  pythia.readString("SpaceShower:ptMaxMatch = 1"); // use SCALUP for ISR

  // If Pythia fails to initialize, exit with error.
  if (!pythia.init()) return 1;

  // Begin event loop. Shower event. Skip if error.
  while (!pythia.info.atEndOfFile()) {
    if (!pythia.next()) continue;

    // Construct new empty HepMC event, fill it and write it out.
    toHepMC.writeNextEvent( pythia );

  // End of event loop. Statistics.
  }
  pythia.stat();

  // Done.
  return 0;
}
```
The event loop now goes on until all events in the `unweighted_events.lhe.gz` file have been read (see `pythia.info.atEndOfFile()`). The parton shower typically starts at the scale of the hard process. The choice of this scale is not unique, and correspondingly `Pythia8` offers several prescriptions through the `ptMaxMatch` setting. The value `ptMaxMatch = 1` instructs `Pythia8` to read the shower starting scale from the `LHE` file. There its value, in the `LHE` lingo known as `SCALUP`, has already been calculated by the hard event generator.

Note that `Pythia8` can load `zlib` compressed `LHE` files. 

---
### Example 9: Comparing `Pythia8` and `MG5_aMC@NLO+Pythia8` predictions

Once we analysed the event samples with `Rivet` we can compare the two predicitions to each other and to data.
```bash
# This is bash 

# Plot two yoda files
dexec rivet-mkhtml-tex DY-MG5.yoda:"Title=MG5+Pythia8" DY.yoda:"Title=Pythia8" -c plot.conf
```
Here `DY-MG5.yoda` and `DY.yoda` contain the results obtained by analysing `MG5_aMC@NLO+Pythia8` with the `rivet` program (see Example 4).

![A screenshot of the index.html website generated by Rivet opened in Safari](pics/rivetScreenshot2.png)

We note that the `MG5_aMC@NLO` prediction is drawn with a multitude of lines. This occurs because `MG5_aMC@NLO` includes scale and PDF variations in the `LHE` events -- each event contains seven weights for the usual 7pt $\mu_f$, $\mu_r$ variation, as well as one weight for each PDF error member (and more). Without specific instructions on how to plot these weights, `Rivet` simply renders all the lines.

Like this, we disable all but the first weight:
```bash
# This is bash

# Plot two yoda files, select single weight
dexec rivet-mkhtml-tex --errs DY-MG5.yoda:"Title=MG5+Pythia8:Variations=none"  DY.yoda:"Title=Pythia8" -c plot.conf

```

And like this, we instruct `Rivet` to render an envelope of a selection of weights into a scale variation band: 
```bash
# This is bash

# Plot two yoda files, with a central curve and a scale variation band
dexec rivet-mkhtml-tex --errs DY-MG5.yoda:"Title=MG5+Pythia8:Variations=none:BandComponentEnv=1,6,11,16,25,30,35,40"  DY.yoda:"Title=Pythia8" -c plot.conf
```

Which weights to select (`1,6,...`) can be figured out by looking at the `.lhe` file:
```
...
<initrwgt>
<weightgroup name="Central scale variation" combine="envelope">
<weight id="1" MUR="0.5"  MUF="0.5"  PDF="247000" > MUR=0.5 MUF=0.5  </weight>
<weight id="2" MUR="0.5"  MUF="0.5"  DYN_SCALE="1"  PDF="247000" > MUR=0.5 MUF=0.5 dyn_scale_choice=sum pt  </weight>
<weight id="3" MUR="0.5"  MUF="0.5"  DYN_SCALE="2"  PDF="247000" > MUR=0.5 MUF=0.5 dyn_scale_choice=HT  </weight>
<weight id="4" MUR="0.5"  MUF="0.5"  DYN_SCALE="3"  PDF="247000" > MUR=0.5 MUF=0.5 dyn_scale_choice=HT/2  </weight>
<weight id="5" MUR="0.5"  MUF="0.5"  DYN_SCALE="4"  PDF="247000" > MUR=0.5 MUF=0.5 dyn_scale_choice=sqrts  </weight>
<weight id="6" MUR="0.5"  MUF="1.0"  PDF="247000" > MUR=0.5  </weight>
<weight id="7" MUR="0.5"  MUF="1.0"  DYN_SCALE="1"  PDF="247000" > MUR=0.5 dyn_scale_choice=sum pt  </weight>
<weight id="8" MUR="0.5"  MUF="1.0"  DYN_SCALE="2"  PDF="247000" > MUR=0.5 dyn_scale_choice=HT  </weight>
<weight id="9" MUR="0.5"  MUF="1.0"  DYN_SCALE="3"  PDF="247000" > MUR=0.5 dyn_scale_choice=HT/2  </weight>
<weight id="10" MUR="0.5"  MUF="1.0"  DYN_SCALE="4"  PDF="247000" > MUR=0.5 dyn_scale_choice=sqrts  </weight>
...
```

This is what the plot looks like with a scale variation band:

<img alt="A screenshot of a single Rivet plot with scale variation band" src="pics/rivetScreenshot3.png" width="400">

---

## NLO+PS matching with `POWHEG BOX`

`POWHEG BOX` is a general-purpose computational framework used in high-energy physics to generate events with next-to-leading-order (NLO) accuracy. It is an implementation of the POWHEG (Positive Weight Hardest Emission Generator) method, which was developed to improve the accuracy of event simulations by combining NLO perturbative QCD calculations with parton shower simulations.

The `POWHEG BOX` code is structured differently from other Monte Carlo generators available on the market. Typically, one downloads the `POWHEG BOX` directory using `git`. This directory only contains the _core subroutines_ needed for event generation with the POWHEG methods, but no processes. It cannot be built on its own. The process directory can also be downloaded using `git` and must be placed into the `POWHEG BOX` directory, and only then can it be built.

In the `mc-tutorial` container `POWHEG BOX V2` is installed in the `/root/POWHEG-BOX-V2/` directory.

---

### Example 10: `POWHEG BOX V2` directory structure and list of processes

For clarity, let us inspect the directory structure of `POWHEG BOX V2`. The command
```bash
# This is shell

# list a directory in the container
docker exec mc-tutorial-powheg ls /root/POWHEG-BOX-V2
```
prints out the following output
```
Bornzerodamp.f         checkmomzero.f         integrator.f     newunit.f                        pwhg_bookhist.f            sigcollsoft.f
Check_LesHouches.f     decidemerging.f        lhapdf6if.f      opencount.f                      pwhg_init.f                sigreal.f
Docs                   fastjetktwrap.cc       lhapdf6ifcc.cc   pdfcalls-hook1.h                 pwhg_io_interface.f        sigremnants.f
GoSamStuff             fastjetsisconewrap.cc  lhapdfif.f       pdfcalls.f                       pwhg_main.f                sigsoftvirt.f
Herwig7.1              find_regions.f         lhef_analysis.f  pdfdata                          pwhgreweight.f             sigvirtual.f
LesHouches.f           findflavperm.f         lhefread.f       pdfdummies.f                     pythia-6.4.21.f            svnversion
LesHouchesreg.f        gen_Born_phsp.f        lhefwrite.f      powheginput.f                    pythia-6.4.25.f            test-integrator
MadGraphStuff          gen_index.f            loadstorenlo.f   progress                         pythia.f                   test_Sudakov.f
MiNNLOStuff            gen_radiation.f        main-HERWIG.f    pt2maxreg.f                      random.f                   test_pwhg_book.f
Scripts                gen_real_phsp.f        main-PYTHIA.f    pwhg_analysis-dummy.f            reshufflemoms.f            ubprojections.f
Z                      herwig.f               maxrat.f         pwhg_analysis_driver.f           rwl_setup_param_weights.f  utils.f
bbinit.f               herwig6510.f           mergedata.f      pwhg_bookhist-multi-extra-new.f  rwl_weightlists.f          validflav.f
boostrot.f             hvq                    mint_upb.f       pwhg_bookhist-multi-extra.f      setlocalscales.f           zlibdummy.c
bra_ket_subroutines.f  hvqpdfpho.f            mlmpdfif.f       pwhg_bookhist-multi-new.f        setstrongcoupl.f
btilde.f               include                multi_plot.f     pwhg_bookhist-multi.f            sigborn.f
cernroutines.f         init_phys.f            mwarn.f          pwhg_bookhist-new.f              sigcollremn.f
```
Here, the directories `Z` and `hvq` are the two processes that I downloaded and built, corresponding to the NC Drell-Yan production ($l^+l^-$) and the top pair production ($t \bar{t}$) processes.

The full list of processes is available on the `POWHEG BOX` [website](https://powhegbox.mib.infn.it/). The names of the process directories are not unambiguous, so it's always a good idea to read through the corresponding publication.

---

### Example 11: Generating $l^+l-$ events at NLO in `POWHEG BOX`
The main program for each process is called `pwhg_main`. I have appended both process directories into `PATH` and renamed them to `pwhg_main-Z` and `pwhg_main-hvq`. In this example, we will only use `pwhg_main-Z`.

The program looks for the run card `powheg.input` in the current working directory and generates a lot of files during its run. Let us first create a dedicated run directory:
```bash
# This is shell

# create a run directory 
mkdir POWHEG_l+l-
```
Here is a minimal `powheg.input` run card for the `POWHEG-BOX/Z` process:
```
! This is powheg.input

! Z production parameter
vdecaymode 1      !(1:leptonic decay, 2:muonic decay, 3: tauonic decay,...)
Zmass 91.1876d0
Zwidth 2.4952d0
mass_low 60        ! lower limit for dilepton mass
mass_high 120      ! upper limit for dilepton mass

numevts 10000    ! number of events to be generated
ih1   1           ! hadron 1 (1 for protons, -1 for antiprotons)
ih2   1           ! hadron 2 (1 for protons, -1 for antiprotons)
! Ignored when using LHAPDF
ndns1 131         ! pdf set for hadron 1 (mlm numbering)
ndns2 131         ! pdf set for hadron 2 (mlm numbering)
ebeam1 6500d0    ! energy of beam 1
ebeam2 6500d0    ! energy of beam 2
! To be set when using LHAPDF
lhans1 93000      ! pdf set for hadron 1 (LHA numbering)
lhans2 93000      ! pdf set for hadron 2 (LHA numbering)

! Parameters to allow or not the use of stored data
use-old-grid    1 ! if 1 use old grid if file pwggrids.dat is present (<> 1 regenerate)
use-old-ubound  1 ! if 1 use norm of upper bounding function stored in pwgubound.dat, if present; <> 1 regenerate

ncall1 100000   ! number of calls for initializing the integration grid
itmx1    5     ! number of iterations for initializing the integration grid
ncall2 100000   ! number of calls for computing the integral and finding upper bound
itmx2    5     ! number of iterations for computing the integral and finding upper bound
foldcsi   1    ! number of folds on csi integration
foldy     1    ! number of folds on  y  integration
foldphi   1    ! number of folds on phi integration
nubound 20000  ! number of bbarra calls to setup norm of upper bounding function
icsimax  1     ! <= 100, number of csi subdivision when computing the upper bounds
iymax    1     ! <= 100, number of y subdivision when computing the upper bounds
xupbound 2d0   ! increase upper bound for radiation generation

! OPTIONAL PARAMETERS
#iseed    12345    ! initialize random number sequence
#rand1     -1      ! initialize random number sequence
#rand2     -1      ! initialize random number sequence

#runningscale 0    ! default is 1, true, central scale equal to Z/gamma virtuality, 0 equal to M_Z
```
Make sure you create the `powheg.input` file in the `POWHG_l+l-` directory and copy the above run card into it. The `mc-tutorial-powheg` image also contains the `nano` editor. Here is how you could use it for this task:
```bash
# This is shell

# launch nano
docker exec -it mc-tutorial-powheg nano POWHEG_l+l-/powheg.input
```
There, you can simply copy&paste the run card. Then press `ctrl+O` to "Write Out", and you'll be prompted to confirm the file name. After that, you can exit by pressing `ctrl+X`.

`POWHEG BOX` is launched as follows. 
```bash
# This is shell

# run pwhg_main for the Z process
docker exec -w /home/POWHEG_l+l- mc-tutorial-powheg pwhg_main-Z
```
Here, the flag `-w /home/POWHEG_l+l-` indicates that we want to launch the command in the `/home/POWHEG_l+l-` directory. This is necessary since the default directory upon launching `docker exec` is `/home`.

The program will start calculating the differential cross sections and will eventually generate events. The entire process, with a goal 10k events, takes about 1m on my laptop. The total cross section is reported in the file `pwgstat.dat`:
```bash
# This is shell

# print the content of the pwg-stat.dat file
docker exec -w /home/POWHEG_l+l- mc-tutorial-powheg cat pwg-stat.dat
```
prints
```
 btilde pos.   weights:   2072.3105785274079       +-  0.86248316776047951     
 btilde |neg.| weights:   18.714742955274048       +-  0.23162351550630880     
 btilde Total (pos.-|neg.|):   2053.5958355721264       +-  0.94373861641199874     
  total (btilde+remnants) cross section in pb   2053.5958355721264      +-  0.94373861641199874     
  negative weight fraction:   8.9500317203256366E-003
```
We see that the obtained precision on the total cross section is about 0.5 permil. If we multiply the number of calls in the `ncall2` setting by a factor of 25, we should approach a precision of 0.1 permil (using the $1/\sqrt{N}$ law of scaling of the MC integration error). This file should always be inspected to ensure that the precision of the differential cross section used for generating the events is appropriate.

We also note that the fraction of negative weights is under 1%, which is excellent.

The generated events are stored in the `pwgevents.lhe` file. By default, this file is not compressed on-the-fly, but compression can be enabled to save HDD space by including the following line in the `powheg.input` file:
```
! This is powheg.input
compress_lhe 1 ! enables compression of .lhe files on-the-fly
```
However, note that `POWHEG BOX` does not append `.gz` to compressed files and expects users and other programs to determine whether the file is compressed themselves.

The program is set up to run at next-to-leading order (NLO) accuracy by default. If you want the events to be at leading order (LO), you must add the following lines to the `powheg.input` file:
```
! This is powheg.input
bornonly 1 ! calculate differential cross sections at LO
LOevents 1 ! generate events without attaching an extra emission
```

The calculation of the differential cross section and upper bounds can be time-consuming (potentially taking days on hundreds of cores for complicated processes). To save time, the program allows you to reuse the results for the _grids_ (cross sections) and _ubounds_ (upper bounds). 
```
use-old-grid    1 ! if 1 use old grid if file pwggrids.dat is present (<> 1 regenerate)
use-old-ubound  1 ! if 1 use norm of upper bounding function stored in pwgubound.dat, if present; <> 1 regenerate
```
These settings were already enabled above, and if the results do not yet exist, they will be calculated anew.
They have two important consequences:
1. If you want to add more events, you can start the run in an existing run directory with the `pwgevents.lhe` file moved away. Such a directory is often referred to as a _grid pack_.
2. If you change physics inputs, you must rerun in a _clean_ run directory or with these two settings disabled. The program will not check the consistency of the settings between the `powheg.input` and existing grids, so you may get inconsistent results. 
---

### Example 12: Showering `POWHEG BOX` events with `Pythia8`
`POWHEG BOX` also generated events in the `.lhe` format, so to shower them we can reuse the program from Example 8 in [Session 1](session1_examples.md)
```c++
// This is C++

#include "Pythia8/Pythia.h"
#include "Pythia8Plugins/HepMC3.h"
#include "Pythia8Plugins/PowhegHooks.h"
using namespace Pythia8;

int main() {

  // Interface for conversion from Pythia8::Event to HepMC event.
  // Specify file where HepMC events will be stored.
  Pythia8ToHepMC toHepMC("DY-POWHEG.hepmc");

  // LHE event loader.
  Pythia pythia;
  // Set up UserHook for showering POWHEG events
  shared_ptr<PowhegHooks> powhegHooks;
  powhegHooks = make_shared<PowhegHooks>();
  pythia.setUserHooksPtr((UserHooksPtr)powhegHooks);
  pythia.readString("POWHEG:Veto = 1"); // Switch the hook on
  pythia.readString("Beams:frameType = 4"); // Switch on loading of LHE files
  pythia.readString("Beams:LHEF = POWHEG_l+l-/pwgevents.lhe"); // Set the LHE path and filename
  pythia.readString("TimeShower:ptMaxMatch = 2"); // Unrestricted FSR
  pythia.readString("SpaceShower:ptMaxMatch = 2"); // Unrestricted ISR

  // If Pythia fails to initialize, exit with error.
  if (!pythia.init()) return 1;

  // Begin event loop. Shower event. Skip if error.
  while (!pythia.info.atEndOfFile()) {
    if (!pythia.next()) continue;

    // Construct new empty HepMC event, fill it and write it out.
    toHepMC.writeNextEvent( pythia );

  // End of event loop. Statistics.
  }
  pythia.stat();

  // Done.
  return 0;
}
```
I save the content the code into `mymain131-powheg.cc`. Note that you need to compile it with the `Docker` container from the previous session:
```bash
# This is shell

# build the mymain131-powheg program
docker exec mc-tutorial make mymain131-powheg
```
Note here the use of `mc-tutorial` instead of `mc-tutorial-powheg`. As before, you will need to add the `mymain131-powheg` target to the `Makefile`.

Besides two trivial differences compared to Example 8:

1. The name of the output file is `DY-POWHEG.hepmc3`.
2. The name and path of the input file is `POWHEG_l+l-/pwgevents.lhe`.

There are two very important differences:

1. **Shower Starting Scale**: Instead of letting `Pythia8` read the shower starting scale `SCALUP` from the `LHE` file, we let the shower evolution start at the highest available scale by setting `ptMaxMatch = 2` instead of `ptMaxMatch = 1`.

2. **Veto Emissions**: We configure the `PowhegHooks` plugin to veto any emissions that `Pythia8` tries to attach if they are harder than the emission already attached by POWHEG. 

   ```c++
   // This is C++

   shared_ptr<PowhegHooks> powhegHooks;
   powhegHooks = make_shared<PowhegHooks>();
   pythia.setUserHooksPtr((UserHooksPtr)powhegHooks);
   pythia.readString("POWHEG:Veto = 1"); // Switch the hook on
   pythia.readString("TimeShower:ptMaxMatch = 2"); // Unrestricted FSR
   pythia.readString("SpaceShower:ptMaxMatch = 2"); // Unrestricted ISR
   ```

Even though the `SCALUP` variable has been introduced to prevent double counting and with `ptMaxMatch = 1`, `Pythia8` emissions would not exceed it, there is a minor catch. The definition of the shower evolution scale in `Pythia8` does not perfectly align with the definition of the hardness scale of the hardest emission in POWHEG. 

The `PowhegHooks` plugin addresses this issue. Although the numerical impact is often small, it can become significant for some processes.

## Appendix

Here we provide more information on topics we may have assumed that you already knew including a couple of useful references. 

### `MG5_aMC@NLO` (excerpt from the [MG5_aMC@NLO website](https://launchpad.net/mg5amcnlo))

`MadGraph5_aMC@NLO` is a framework that aims at providing all the elements necessary for SM and BSM phenomenology, such as the computations of cross sections, the generation of hard events and their matching with event generators, and the use of a variety of tools relevant to event manipulation and analysis. Processes can be simulated to LO accuracy for any user-defined Lagrangian, an the NLO accuracy in the case of models that support this kind of calculations -- prominent among these are QCD and EW corrections to SM processes. Matrix elements at the tree- and one-loop-level can also be obtained.

`MadGraph5_aMC@NLO` is the new version of both MadGraph5 and aMC@NLO that unifies the LO and NLO lines of development of automated tools within the MadGraph family. It therefore supersedes all the MadGraph5 1.5.x versions and all the beta versions of aMC@NLO. As such, the code allows one to simulate processes in virtually all configurations of interest, in particular for hadronic and e+e- colliders; starting from version 3.2.0, the latter include Initial State Radiation and beamstrahlung effects.


### `LHE` 

The `LHE` (Les Houches Event) file format is a standardized format used in high-energy physics to store information about the events generated by MC event generators. It was developed as part of the Les Houches Accords, which aim to improve the interoperability between different tools and software used in particle physics.

The `.lhe` files look something like this 
```
<LesHouchesEvents version="xy">
<header>
  <!-- Optional information like the process, PDF, scale settings, etc. -->
  <init>
    2212 2212 6.500000e+03 6.500000e+03 0 0 247000 247000 -4 1
    1.688680e+03 3.705036e+00 1.688680e+03 1
  </init>
</header>
<event>
       5      1 +1.6886800e+03 9.22950200e+01 7.54677100e-03 1.29738700e-01
       -2 -1    0    0    0  501 -0.0000000000e+00 +0.0000000000e+00 +5.3771879862e+00 5.3771879862e+00 0.0000000000e+00 0.0000e+00 -1.0000e+00
        2 -1    0    0  501    0 +0.0000000000e+00 -0.0000000000e+00 -3.9604206752e+02 3.9604206752e+02 0.0000000000e+00 0.0000e+00 1.0000e+00
       23  2    1    2    0    0 +0.0000000000e+00 +0.0000000000e+00 -3.9066487954e+02 4.0141925551e+02 9.2295019314e+01 0.0000e+00 0.0000e+00
      -11  1    3    3    0    0 -4.0335354915e+01 -2.2291993046e+01 -2.0573340903e+02 2.1083194587e+02 0.0000000000e+00 0.0000e+00 -1.0000e+00
       11  1    3    3    0    0 +4.0335354915e+01 +2.2291993046e+01 -1.8493147051e+02 1.9058730964e+02 0.0000000000e+00 0.0000e+00 1.0000e+00
</event>
</LesHouchesEvents>
```
The `<init>` block contains information about the beams (incoming particles), their energies, ...
The numbers 2212 2212 represent the PDG IDs of the incoming particles, which are protons in this case.
6500 6500 are the beam energies in GeV.
The remaining numbers can correspond to PDF IDs, factorization scales, and other relevant settings.

Each `<event>` block contains the details of one simulated event.
The first line after `<event>` summarizes the event:
- 5: The number of particles in the event.
- +1.6886800e+03: An event weight.
- 9.22950200e+01: The hard scale in the event.
- etc.

Each subsequent line describes a particle in the event. These entries include:
- PDG ID: The particle's PDG code (e.g., -1 for a down quark, 1 for an up quark).
- Status Code: Indicates the particle's status in the event (e.g., initial state, final state, intermediate).
- Parent 1 and Parent 2: Indices of the parent particles that produced this particle.
- Daughters: Indices of the particles produced by this particle (if any).
- Momentum (px, py, pz, E, m): The particle's 4-momentum (momentum components in GeV, energy in GeV, and mass in GeV).
- Spin Information: (optional) Spin/helicity information.
